ARM GAS  /tmp/ccQnxdM2.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"cmd_app.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.cmd_add_Init,"ax",%progbits
  19              		.align	2
  20              		.global	cmd_add_Init
  21              		.thumb
  22              		.thumb_func
  24              	cmd_add_Init:
  25              	.LFB64:
  26              		.file 1 "Src/cmd_app.c"
   1:Src/cmd_app.c **** /*
   2:Src/cmd_app.c ****  * cmd_app.c
   3:Src/cmd_app.c ****  *
   4:Src/cmd_app.c ****  *  Created on: Nov 14, 2018
   5:Src/cmd_app.c ****  *      Author: bitohw03
   6:Src/cmd_app.c ****  */
   7:Src/cmd_app.c **** 
   8:Src/cmd_app.c **** #include <string.h>
   9:Src/cmd_app.c **** #include <stdlib.h>
  10:Src/cmd_app.c **** #include <stdio.h>
  11:Src/cmd_app.c **** #include "stm32f1xx_hal.h"
  12:Src/cmd_app.c **** #include "common.h"
  13:Src/cmd_app.c **** //#include "cli.c"
  14:Src/cmd_app.c **** #include "cmd_app.h"
  15:Src/cmd_app.c **** 
  16:Src/cmd_app.c **** 
  17:Src/cmd_app.c **** 
  18:Src/cmd_app.c **** static HAL_StatusTypeDef prvDispOprwConfig(int argc, char** argv)
  19:Src/cmd_app.c **** {
  20:Src/cmd_app.c **** 	I2C_DATA_T i2c_data;
  21:Src/cmd_app.c **** 	uint8_t databuff[256];
  22:Src/cmd_app.c **** 	uint8_t result = HAL_ERROR;
  23:Src/cmd_app.c **** 
  24:Src/cmd_app.c **** 	if (!strcmp(argv[0],"opw") )
  25:Src/cmd_app.c **** 	{
  26:Src/cmd_app.c **** 		i2c_data.rwType = WRITE_CMD;
  27:Src/cmd_app.c **** 	}
  28:Src/cmd_app.c **** 	else if (!strcmp(argv[0],"opr") )
  29:Src/cmd_app.c **** 	{
  30:Src/cmd_app.c **** 		i2c_data.rwType = READ_CMD;
  31:Src/cmd_app.c **** 	}
  32:Src/cmd_app.c **** 
ARM GAS  /tmp/ccQnxdM2.s 			page 2


  33:Src/cmd_app.c **** 	i2c_data.devAddr 	= com_str_to_int16(argv[1]);
  34:Src/cmd_app.c **** 	i2c_data.offsetAddr = com_str_to_int16(argv[2]);
  35:Src/cmd_app.c **** 	i2c_data.readData   = databuff;
  36:Src/cmd_app.c **** 	i2c_data.writeData  = databuff;
  37:Src/cmd_app.c **** 	i2c_data.i2c_dbg_mode = false;  //false:normal i2c mode,true:dbg i2c mode
  38:Src/cmd_app.c **** 
  39:Src/cmd_app.c **** 	if(i2c_data.rwType == READ_CMD)
  40:Src/cmd_app.c **** 	{
  41:Src/cmd_app.c **** 		if(argc == 3)
  42:Src/cmd_app.c **** 		{
  43:Src/cmd_app.c **** 			i2c_data.rwByteNum = 1;
  44:Src/cmd_app.c **** 		}
  45:Src/cmd_app.c **** 		else
  46:Src/cmd_app.c **** 		{
  47:Src/cmd_app.c **** 			i2c_data.rwByteNum = com_str_to_int16(argv[3]);
  48:Src/cmd_app.c **** 		}
  49:Src/cmd_app.c **** 	}
  50:Src/cmd_app.c **** 	else
  51:Src/cmd_app.c **** 	{
  52:Src/cmd_app.c **** 		uint8_t i = 0, index = 0;
  53:Src/cmd_app.c **** 
  54:Src/cmd_app.c **** 		if(argc == 0x4)
  55:Src/cmd_app.c **** 		{
  56:Src/cmd_app.c **** 			i2c_data.rwByteNum = argc - 3;
  57:Src/cmd_app.c **** 			index = 3;
  58:Src/cmd_app.c **** 
  59:Src/cmd_app.c **** 		}
  60:Src/cmd_app.c **** 		else if(argc > 0x4)
  61:Src/cmd_app.c **** 		{
  62:Src/cmd_app.c **** 			i2c_data.rwByteNum = argc - 4;
  63:Src/cmd_app.c **** 			index = 4;
  64:Src/cmd_app.c **** 		}
  65:Src/cmd_app.c **** 
  66:Src/cmd_app.c **** 		for(i= 0; i < i2c_data.rwByteNum;i++ )
  67:Src/cmd_app.c **** 		{
  68:Src/cmd_app.c **** 			databuff[i] = com_str_to_int16(argv[index + i]);
  69:Src/cmd_app.c **** 		}
  70:Src/cmd_app.c **** 	}
  71:Src/cmd_app.c **** 
  72:Src/cmd_app.c **** 	if(i2c_data.rwType == READ_CMD)
  73:Src/cmd_app.c **** 	{
  74:Src/cmd_app.c **** 	//		result = smb_read_multi_byte( i2c_data.devAddr, i2c_data.offsetAddr,  i2c_data.readData, i2c_d
  75:Src/cmd_app.c **** 	}
  76:Src/cmd_app.c **** 	else
  77:Src/cmd_app.c **** 	{
  78:Src/cmd_app.c **** 	//		result = smb_write_multi_byte( i2c_data.devAddr, i2c_data.offsetAddr,  i2c_data.readData, i2c_
  79:Src/cmd_app.c **** 	}
  80:Src/cmd_app.c **** 
  81:Src/cmd_app.c **** 	if(result == HAL_OK)
  82:Src/cmd_app.c **** 	{
  83:Src/cmd_app.c **** 		printf(" \r\n The value on page (0x%x), index(0x%x) : ",i2c_data.devAddr,i2c_data.offsetAddr);
  84:Src/cmd_app.c **** 		while(i2c_data.rwByteNum --)
  85:Src/cmd_app.c **** 		{
  86:Src/cmd_app.c **** 			printf(" 0x%x",*(i2c_data.readData++));
  87:Src/cmd_app.c **** 		}
  88:Src/cmd_app.c **** 	}
  89:Src/cmd_app.c **** 	return result;
ARM GAS  /tmp/ccQnxdM2.s 			page 3


  90:Src/cmd_app.c **** }
  91:Src/cmd_app.c **** 
  92:Src/cmd_app.c **** void cmd_add_Init(void)
  93:Src/cmd_app.c **** {
  27              		.loc 1 93 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32 0000 7047     		bx	lr
  33              		.cfi_endproc
  34              	.LFE64:
  36 0002 00BF     		.text
  37              	.Letext0:
  38              		.file 2 "/usr/include/newlib/machine/_default_types.h"
  39              		.file 3 "/usr/include/newlib/sys/_stdint.h"
  40              		.file 4 "Drivers/CMSIS/Include/core_cm3.h"
ARM GAS  /tmp/ccQnxdM2.s 			page 4


DEFINED SYMBOLS
                            *ABS*:0000000000000000 cmd_app.c
     /tmp/ccQnxdM2.s:19     .text.cmd_add_Init:0000000000000000 $t
     /tmp/ccQnxdM2.s:24     .text.cmd_add_Init:0000000000000000 cmd_add_Init
                     .debug_frame:0000000000000010 $d

NO UNDEFINED SYMBOLS
